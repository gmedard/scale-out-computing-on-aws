AWSTemplateFormatVersion: 2010-09-09
Description: (SOCA) - Manage security stack.
Parameters:
  VpcId:
    Type: AWS::EC2::VPC::Id

  VpcCidr:
    Type: String
  
  SocaDomain:
    Type: String

  HostedZoneId:
    Type: AWS::Route53::HostedZone::Id

  AL2ImageId:
    Type: AWS::EC2::Image::Id

  SSHKeyPair:
    Type: AWS::EC2::KeyPair::KeyName

  RepositoryBucket:
    Type: String

  RepositoryFolder:
    Type: String

  BastionInstanceType:
    Type: String

  ProxyInstanceType:
    Type: String

  ProxySubnetId:
    Type: AWS::EC2::Subnet::Id

  NoProxy:
    Type: String

  UpdateDnsLambdaArn:
    Type: String

  PublicSubnet1:
    Type: AWS::EC2::Subnet::Id

  PublicSubnet2:
    Type: AWS::EC2::Subnet::Id

  PrivateSubnet1:
    Type: AWS::EC2::Subnet::Id

  PrivateSubnet2:
    Type: AWS::EC2::Subnet::Id

  PrivateSubnet3:
    Type: AWS::EC2::Subnet::Id

  PrivateRouteTable:
    Type: String

  ClientIp:
    Type: String

  PrefixListId:
    Type: String

  SchedulerPublicIP:
    Type: String

  EIPNat:
    Type: String

  ClusterId:
    Type: String

  S3InstallBucket:
    Type: String

  S3InstallFolder:
    Type: String

Conditions:
  HasClientIp:
    !Not [ !Equals [ !Ref ClientIp, '' ] ]

  HasPrefixListId:
    !Not [ !Equals [ !Ref PrefixListId, '' ] ]

  HasRepository:
    !Not [ !Equals [ !Ref RepositoryBucket, '' ] ]

Resources:

  #============================================================================
  # Custom resource to get regional S3 prefix list Id
  # This is needed to allow egress to the s3 gateway endpoint
  #============================================================================

  GetPrefixListLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: PreRequisite
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:DeleteLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":logs:", !Ref "AWS::Region", ":", !Ref  "AWS::AccountId", ":log-group:/aws/lambda/", !Ref ClusterId, "*"] ]

              - Effect: Allow
                Action:
                  - ec2:DescribePrefixLists
                Resource:
                  - '*'

  GetPrefixListLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Get Prefix list id
      FunctionName: !Sub "${ClusterId}-GetPrefixList"
      Handler: index.lambda_handler
      MemorySize: 128
      Role: !GetAtt GetPrefixListLambdaRole.Arn
      Runtime: python3.7
      Timeout: 180
      Tags:
        - Key: soca:ClusterId
          Value: !Ref ClusterId
      Code:
        ZipFile: !Sub |
          import cfnresponse
          import boto3
          import logging
          '''
          Get prefix list id
          '''
          logging.getLogger().setLevel(logging.INFO)
          def lambda_handler(event, context):
            try:
              logging.info("event: {}".format(event))
              prefixListName = event['ResourceProperties']['PrefixListName']

              ec2_client = boto3.client('ec2')
              prefixListId = ec2_client.describe_prefix_lists(Filters=[{'Name': 'prefix-list-name', 'Values': [prefixListName]}])['PrefixLists'][0]['PrefixListId']
            except:
              logging.exception("Unhandled exception")
              error_message = 'Exception getting prefix list id for {}'.format(prefixListName)
              cfnresponse.send(event, context, cfnresponse.FAILED, {'error': error_message}, error_message)

            cfnresponse.send(event, context, cfnresponse.SUCCESS, {'Id': prefixListId}, prefixListId)

  S3PrefixList:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt GetPrefixListLambda.Arn
      PrefixListName: !Sub "com.amazonaws.${AWS::Region}.s3"

  #============================================================================
  # VPC Endpoints
  #============================================================================

  S3VpcEndpoint:
    # https://docs.aws.amazon.com/vpc/latest/userguide/vpc-endpoints-s3.html
    Type: AWS::EC2::VPCEndpoint
    Properties:
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.s3"
      VpcEndpointType: Gateway
      VpcId: !Ref VpcId
      RouteTableIds:
        - !Ref PrivateRouteTable
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: Allow
          Principal: "*"
          Action:
            - "s3:GetObject"
            - "s3:List*"
          Resource:
            - !Sub "arn:aws:s3:::amazonlinux.${AWS::Region}.amazonaws.com/*"
            - !Sub "arn:aws:s3:::packages.${AWS::Region}.amazonaws.com/*"
            - !Sub "arn:aws:s3:::repo.${AWS::Region}.amazonaws.com/*"
            # SSM Agent
            - !Sub "arn:aws:s3:::ec2-downloads-windows/*"
            # CloudWatch Agent
            - !Sub "arn:${AWS::Partition}:s3:::amazoncloudwatch-agent-${AWS::Region}/*"
            # NVidia drivers
            - !Sub "arn:aws:s3:::ec2-linux-nvidia-drivers"
            - !Sub "arn:aws:s3:::ec2-linux-nvidia-drivers/*"
            - !If [ HasRepository, !Sub "arn:${AWS::Partition}:s3:::${RepositoryBucket}/${RepositoryFolder}/*", !Ref 'AWS::NoValue' ]
        - Effect: Allow
          Principal: "*"
          Action:
            - "s3:DeleteObject"
            - "s3:GetObject"
            - "s3:PutObject"
            - "s3:List*"
          Resource:
            - !Sub "arn:aws:s3:::${S3InstallBucket}"
            - !Sub "arn:aws:s3:::${S3InstallBucket}/${S3InstallFolder}/*"
        # Cloudformation wait conditions
        # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-vpce-bucketnames.html
        - Effect: Allow
          Principal: "*"
          Action:
            - "s3:PutObject"
          Resource:
            - !Sub "arn:aws:s3:::cloudformation-waitcondition-${AWS::Region}"
            - !Sub "arn:aws:s3:::cloudformation-waitcondition-${AWS::Region}/*"
          # This breaks s3 bucket access for yum
          # Condition:
          #   StringEquals:
          #     "aws:PrincipalAccount": !Ref "AWS::AccountId"

        # Systems Manager
        # https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-agent-minimum-s3-permissions.html
        - Effect: Allow
          Principal: "*"
          Action:
            - "s3:GetObject"
          Resource:
            - !Sub "arn:aws:s3:::aws-ssm-${AWS::Region}/*"
            - !Sub "arn:aws:s3:::aws-windows-downloads-${AWS::Region}/*"
            - !Sub "arn:aws:s3:::amazon-ssm-${AWS::Region}/*"
            - !Sub "arn:aws:s3:::amazon-ssm-packages-${AWS::Region}/*"
            - !Sub "arn:aws:s3:::${AWS::Region}-birdwatcher-prod/*"
            - !Sub "arn:aws:s3:::patch-baseline-snapshot-${AWS::Region}/*"

  VpcEndpointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "VPC Endpoints"
      Tags:
      - Key: Name
        Value: !Sub "${ClusterId}-VpcEndpointsSG"
      VpcId: !Ref VpcId

  VpcEndpointIgressBastionHTTPS:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourceSecurityGroupId: !GetAtt BastionSecurityGroup.GroupId
      GroupId: !GetAtt VpcEndpointSecurityGroup.GroupId
      Description: "Bastion"

  VpcEndpointIngressComputeNodeHTTPS:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourceSecurityGroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      GroupId: !GetAtt VpcEndpointSecurityGroup.GroupId
      Description: "ComputeNode"

  VpcEndpointIngressImageBuilderHTTPS:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourceSecurityGroupId: !GetAtt ImageBuilderSecurityGroup.GroupId
      GroupId: !GetAtt VpcEndpointSecurityGroup.GroupId
      Description: "ImageBuilder"

  VpcEndpointIngressProxyHTTPS:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourceSecurityGroupId: !GetAtt ProxySecurityGroup.GroupId
      GroupId: !GetAtt VpcEndpointSecurityGroup.GroupId
      Description: "Proxy"

  VpcEndpointIngressSchedulerHTTPS:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourceSecurityGroupId: !GetAtt SchedulerSecurityGroup.GroupId
      GroupId: !GetAtt VpcEndpointSecurityGroup.GroupId
      Description: "Scheduler"

  # AutoscalingVpcEndpoint:
  #   Type: AWS::EC2::VPCEndpoint
  #   Properties:
  #     ServiceName: !Sub "com.amazonaws.${AWS::Region}.autoscaling"
  #     VpcEndpointType: Interface
  #     VpcId: !Ref VpcId
  #     PrivateDnsEnabled: true
  #     SecurityGroupIds:
  #       - !Ref VpcEndpointSecurityGroup
  #     SubnetIds:
  #       - !Ref PrivateSubnet1
  #       - !Ref PrivateSubnet2
  #       - !Ref PrivateSubnet3
  #     PolicyDocument:
  #       Version: "2012-10-17"
  #       Statement:
  #       - Effect: Allow
  #         Principal: "*"
  #         Action:
  #           - "*"
  #         Resource:
  #           - "*"
  #         Condition:
  #           StringEquals:
  #             "aws:PrincipalAccount": !Ref "AWS::AccountId"

  CloudformationVpcEndpoint:
    # Service com.amazonaws.us-east-1.cloudformation only supports the full-access endpoint policy
    Type: AWS::EC2::VPCEndpoint
    Properties:
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.cloudformation"
      VpcEndpointType: Interface
      VpcId: !Ref VpcId
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref VpcEndpointSecurityGroup
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
        - !Ref PrivateSubnet3

  # CodecommitVpcEndpoint:
  #   Type: AWS::EC2::VPCEndpoint
  #   Properties:
  #     ServiceName: !Sub "com.amazonaws.${AWS::Region}.codecommit"
  #     VpcEndpointType: Interface
  #     VpcId: !Ref VpcId
  #     PrivateDnsEnabled: true
  #     SecurityGroupIds:
  #       - !Ref VpcEndpointSecurityGroup
  #     SubnetIds:
  #       - !Ref PrivateSubnet1
  #       - !Ref PrivateSubnet2
  #       - !Ref PrivateSubnet3
  #     PolicyDocument:
  #       Version: "2012-10-17"
  #       Statement:
  #       - Effect: Allow
  #         Principal: "*"
  #         Action:
  #           - "*"
  #         Resource:
  #           - "*"
  #         Condition:
  #           StringEquals:
  #             "aws:PrincipalAccount": !Ref "AWS::AccountId"

  EC2VpcEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.ec2"
      VpcEndpointType: Interface
      VpcId: !Ref VpcId
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref VpcEndpointSecurityGroup
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
        - !Ref PrivateSubnet3
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: Allow
          Principal: "*"
          Action:
            - "*"
          Resource:
            - "*"
          Condition:
            StringEquals:
              "aws:PrincipalAccount": !Ref "AWS::AccountId"

  Ec2MessagesVpcEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.ec2messages"
      VpcEndpointType: Interface
      VpcId: !Ref VpcId
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref VpcEndpointSecurityGroup
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
        - !Ref PrivateSubnet3
      # Service com.amazonaws.us-east-1.ssm only supports the full-access endpoint policy.
      # PolicyDocument:
      #   Version: "2012-10-17"
      #   Statement:
      #   - Effect: Allow
      #     Principal: "*"
      #     Action:
      #       - "*"
      #     Resource:
      #       - "*"
      #     Condition:
      #       StringEquals:
      #         "aws:PrincipalAccount": !Ref "AWS::AccountId"

  # ElasticFileSystemVpcEndpoint:
  #   Type: AWS::EC2::VPCEndpoint
  #   Properties:
  #     ServiceName: !Sub "com.amazonaws.${AWS::Region}.elasticfilesystem"
  #     VpcEndpointType: Interface
  #     VpcId: !Ref VpcId
  #     PrivateDnsEnabled: true
  #     SecurityGroupIds:
  #       - !Ref VpcEndpointSecurityGroup
  #     SubnetIds:
  #       - !Ref PrivateSubnet1
  #       - !Ref PrivateSubnet2
  #       - !Ref PrivateSubnet3
  #     PolicyDocument:
  #       Version: "2012-10-17"
  #       Statement:
  #       - Effect: Allow
  #         Principal: "*"
  #         Action:
  #           - "*"
  #         Resource:
  #           - "*"
  #         Condition:
  #           StringEquals:
  #             "aws:PrincipalAccount": !Ref "AWS::AccountId"

  LogsVpcEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.logs"
      VpcEndpointType: Interface
      VpcId: !Ref VpcId
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref VpcEndpointSecurityGroup
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
        - !Ref PrivateSubnet3
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: Allow
          Principal: "*"
          Action:
            - "*"
          Resource:
            - "*"
          Condition:
            StringEquals:
              "aws:PrincipalAccount": !Ref "AWS::AccountId"

  SecretsManagerVpcEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.secretsmanager"
      VpcEndpointType: Interface
      VpcId: !Ref VpcId
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref VpcEndpointSecurityGroup
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
        - !Ref PrivateSubnet3
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: Allow
          Principal: "*"
          Action:
            - "*"
          Resource:
            - "*"
          Condition:
            StringEquals:
              "aws:PrincipalAccount": !Ref "AWS::AccountId"

  SSMVpcEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.ssm"
      VpcEndpointType: Interface
      VpcId: !Ref VpcId
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref VpcEndpointSecurityGroup
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
        - !Ref PrivateSubnet3
      # Service com.amazonaws.us-east-1.ssm only supports the full-access endpoint policy.
      # PolicyDocument:
      #   Version: "2012-10-17"
      #   Statement:
      #   - Effect: Allow
      #     Principal: "*"
      #     Action:
      #       - "*"
      #     Resource:
      #       - "*"
      #     Condition:
      #       StringEquals:
      #         "aws:PrincipalAccount": !Ref "AWS::AccountId"

  SSMMessagesVpcEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.ssmmessages"
      VpcEndpointType: Interface
      VpcId: !Ref VpcId
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref VpcEndpointSecurityGroup
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
        - !Ref PrivateSubnet3
      # Service com.amazonaws.us-east-1.ssm only supports the full-access endpoint policy.
      # PolicyDocument:
      #   Version: "2012-10-17"
      #   Statement:
      #   - Effect: Allow
      #     Principal: "*"
      #     Action:
      #       - "*"
      #     Resource:
      #       - "*"
      #     Condition:
      #       StringEquals:
      #         "aws:PrincipalAccount": !Ref "AWS::AccountId"

  #============================================================================
  # Bastion server
  #============================================================================

  BastionNLB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      Type: network
      IpAddressType: ipv4
      Subnets: 
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      LoadBalancerAttributes:
        - Key: load_balancing.cross_zone.enabled
          Value: true
        # - Key: access_logs.s3.enabled
        #   Value: true
        # - Key: access_logs.s3.bucket
        #   Value: !Sub "${S3InstallBucket}"
        # - Key: access_logs.s3.prefix
        #   Value: !Sub "${S3InstallFolder}/BastionNLBLogs"
      Tags:
        - Key: soca:ClusterId
          Value: !Sub ${ClusterId}

  #============================================================================
  # Custom resource to get NLB private ip addresses so can allow
  # health checks
  #============================================================================

  GetNLBPrivateIPLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: PreRequisite
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:DeleteLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":logs:", !Ref "AWS::Region", ":", !Ref  "AWS::AccountId", ":log-group:/aws/lambda/", !Ref ClusterId, "*"] ]

              - Effect: Allow
                Action:
                  - elasticloadbalancing:DescribeLoadBalancers
                  - ec2:DescribeNetworkInterfaces
                Resource:
                  - '*'

  GetNLBPrivateIPLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Get NLB private ip addresses
      FunctionName: !Sub "${ClusterId}-GetNLBPrivateIP"
      Handler: index.lambda_handler
      MemorySize: 128
      Role: !GetAtt GetNLBPrivateIPLambdaRole.Arn
      Runtime: python3.7
      Timeout: 180
      Tags:
        - Key: soca:ClusterId
          Value: !Ref ClusterId
      Code:
        ZipFile: !Sub |
          import cfnresponse
          import boto3
          import logging
          import re
          '''
          Get prefix list id
          '''
          logging.getLogger().setLevel(logging.INFO)
          def lambda_handler(event, context):
            try:
              logging.info("event: {}".format(event))
              requestType = event['RequestType']
              if requestType == 'Delete':
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, '')
              loadBalancerArn = event['ResourceProperties']['LoadBalancerArn']
              logging.info("loadBalancerArn: " + loadBalancerArn)
              loadBalancerId = re.sub(r'^.+:loadbalancer/', '', loadBalancerArn)
              logging.info("loadBalancerId: " + loadBalancerId)
              ec2_client = boto3.client('ec2')
              response = ec2_client.describe_network_interfaces(Filters=[{'Name': 'description', 'Values': ['ELB ' + loadBalancerId]}])
              ipAddresses = []
              for networkInterface in response['NetworkInterfaces']:
                logging.debug(networkInterface)
                az = networkInterface['AvailabilityZone']
                logging.info("az: " + az)
                for privateIpAddress in networkInterface['PrivateIpAddresses']:
                  logging.debug(privateIpAddress)
                  ipAddress = privateIpAddress['PrivateIpAddress']
                  logging.info("ipAddress:" + ipAddress)
                  ipAddresses.append(ipAddress)
              if len(ipAddresses) == 0:
                msg = "No IP addresses found"
                logging.error(msg)
                cfnresponse.send(event, context, cfnresponse.FAILED, {'error': msg}, msg)
              else:
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {'IpAddresses': ipAddresses}, str(ipAddresses))
            except:
              logging.exception("Caught exception")
              error_message = 'Exception getting NLB private IP addresses id for {}'.format(loadBalancerArn)
              cfnresponse.send(event, context, cfnresponse.FAILED, {'error': error_message}, error_message)

  BastionNLBCustomResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt GetNLBPrivateIPLambda.Arn
      LoadBalancerArn: !Ref BastionNLB

  BastionNLBTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Protocol: TCP
      Port: 22
      HealthCheckProtocol: TCP
      HealthCheckPort: "22"
      HealthCheckEnabled: true
      HealthCheckIntervalSeconds: 30
      HealthyThresholdCount: 3
      UnhealthyThresholdCount: 3
      VpcId: !Ref VpcId
      Tags:
        - Key: soca:ClusterId
          Value: !Sub ${ClusterId}

  BastionNLBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions: 
        - Type: forward
          TargetGroupArn: !Ref BastionNLBTargetGroup
      LoadBalancerArn: !Ref BastionNLB
      Port: 22
      Protocol: TCP

  BastionIAMRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - !Sub "ec2.${AWS::URLSuffix}"
                - !Sub "ssm.${AWS::URLSuffix}"
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore # Support for SSM
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy  # Support for CloudwatchAgent

      Policies:
        - PolicyName: BastionPermissions
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":s3:::", !Ref S3InstallBucket , "/*" ] ]
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":s3:::", !Ref S3InstallBucket] ]
                  - !If [ HasRepository, !Sub "arn:${AWS::Partition}:s3:::${RepositoryBucket}/${RepositoryFolder}/*", !Ref 'AWS::NoValue' ]

              - Effect: Allow
                Action:
                  - ec2:CreateTags
                Resource:
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:volume/*"
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:network-interface/*"

              - Effect: Allow
                Action:
                  - ec2:DescribeVolumes
                  - ec2:DescribeNetworkInterfaces
                Resource: "*"

  BastionIAMInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref BastionIAMRole

  BastionSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: SG For Bastion Host
      Tags:
        - Key: Name
          Value: !Sub ${ClusterId}-BastionSG
        - Key: soca:ClusterId
          Value: !Ref ClusterId

  BastionIngressNLB1SSH:
    # Used for health checks
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      CidrIp: !Join ["", [!Select [0, !GetAtt BastionNLBCustomResource.IpAddresses], "/32"]]
      GroupId: !GetAtt BastionSecurityGroup.GroupId
      Description: "NLB1"

  BastionIngressNLB2SSH:
    # Used for health checks
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      CidrIp: !Join ["", [!Select [1, !GetAtt BastionNLBCustomResource.IpAddresses], "/32"]]
      GroupId: !GetAtt BastionSecurityGroup.GroupId
      Description: "NLB2"

  BastionIngressClientIpSSH:
    Condition: HasClientIp
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      CidrIp: !Ref ClientIp
      GroupId: !GetAtt BastionSecurityGroup.GroupId
      Description: "ClientIp"

  BastionIngressPrefixListSSH:
    Condition: HasPrefixListId
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      SourcePrefixListId: !Ref PrefixListId
      GroupId: !GetAtt BastionSecurityGroup.GroupId
      Description: "ClientPrefixList"

  BastionLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateData:
        ImageId: !Ref AL2ImageId
        DisableApiTermination: false
        InstanceType: !Ref BastionInstanceType
        IamInstanceProfile:
          Arn: !GetAtt BastionIAMInstanceProfile.Arn
        BlockDeviceMappings:
          - DeviceName: "/dev/xvda"
            Ebs:
              DeleteOnTermination: true
              VolumeSize: 10
              VolumeType: gp2
              Encrypted: true
        KeyName: !Ref SSHKeyPair
        NetworkInterfaces:
          - AssociatePublicIpAddress: "false"
            DeviceIndex: "0"
            Groups: 
              - !Ref BastionSecurityGroup
        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub "${ClusterId}-Bastion"
              - Key: soca:ClusterId
                Value: !Sub ${ClusterId}
              - Key: soca:NodeType
                Value: bastion
          - ResourceType: volume
            Tags:
              - Key: Name
                Value: !Sub "${ClusterId}-Bastion"
              - Key: soca:ClusterId
                Value: !Sub ${ClusterId}
        UserData:
          "Fn::Base64": !Sub |
            #!/bin/bash -xe

            # Configure using ansible
            # This can be done before configuring the proxy because S3 is accessed using the S3 VPC endpoint
            amazon-linux-extras install -y ansible2
            aws s3 cp --recursive s3://${S3InstallBucket}/${S3InstallFolder}/playbooks/ /root/playbooks/
            cd /root/playbooks
            ansible-playbook bastion.yml -e Region=${AWS::Region} -e Domain=${SocaDomain} -e S3InstallBucket=${S3InstallBucket} -e S3InstallFolder=${S3InstallFolder} -e ClusterId=${ClusterId} -e NoProxy=${NoProxy} -e NodeType=bastion >> /root/ansible.log 2>&1

            source /etc/profile.d/proxy.sh

            # Signal Cloudformation if the instance creates successfully or not
            yum -y install -y aws-cfn-bootstrap
            function on_exit {
                /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource BastionAutoScalingGroup --region ${AWS::Region} || true
            }
            trap on_exit EXIT

            #ansible-playbook configure-repo.yml -e Region=${AWS::Region} -e Domain=${SocaDomain} -e S3InstallBucket=${S3InstallBucket} -e S3InstallFolder=${S3InstallFolder} -e ClusterId=${ClusterId} -e NoProxy=${NoProxy} -e RepositoryBucket=${RepositoryBucket} -e RepositoryFolder=${RepositoryFolder} >> /root/ansible-configure-repo.log 2>&1

            yum -y update --security

            # Tag EBS disks manually as CFN ASG does not support it
            AWS_AVAIL_ZONE=$(curl http://169.254.169.254/latest/meta-data/placement/availability-zone)
            AWS_REGION="`echo \"$AWS_AVAIL_ZONE\" | sed "s/[a-z]$//"`"
            AWS_INSTANCE_ID=$(curl http://169.254.169.254/latest/meta-data/instance-id)
            EBS_IDS=$(aws ec2 describe-volumes --filters Name=attachment.instance-id,Values="$AWS_INSTANCE_ID" --region $AWS_REGION --query "Volumes[*].[VolumeId]" --out text | tr "\n" " ")
            aws ec2 create-tags --resources $EBS_IDS --region $AWS_REGION --tags Key=Name,Value="${ClusterId} Root Disk" "Key=soca:ClusterId,Value=${ClusterId}"

            # Tag Network Adapter for the Proxy
            ENI_IDS=$(aws ec2 describe-network-interfaces --filters Name=attachment.instance-id,Values="$AWS_INSTANCE_ID" --region $AWS_REGION --query "NetworkInterfaces[*].[NetworkInterfaceId]" --out text | tr "\n" " ")
            aws ec2 create-tags --resources $ENI_IDS --region $AWS_REGION --tags Key=Name,Value="${ClusterId} Proxy Network Adapter" "Key=soca:ClusterId,Value=${ClusterId}"

            # Disable automatic motd update
            /usr/sbin/update-motd --disable
            rm -f /etc/cron.d/update-motd
            rm -f /etc/update-motd.d/*

            # Set up motd
            # Cloud init apparently overwrites it after UserData is run so create a script to run it after reboot.
            # Will make sure that there is a reboot so motd gets updated
            amazon-linux-extras install -y epel
            yum -y install figlet
            figlet -f slant "SOCA Bastion" > /etc/motd
            echo -e "Cluster: ${ClusterId}
            > ssh username@hostname
            > ssh username@privateip
            " >> /etc/motd

            /opt/aws/bin/cfn-signal -e 0 --stack ${AWS::StackName} --resource BastionAutoScalingGroup --region ${AWS::Region} || true
            
            if ! needs-restarting -r; then
              reboot
            fi

  BastionAutoScalingGroup:
    # Create the Proxy first because the bastion is in a private subnet and should be proxied too.
    DependsOn:
      - BastionIngressNLB1SSH
      - BastionIngressNLB2SSH
      - EC2VpcEndpoint
      - ProxyEC2Instance
      - ProxyIgressBastionSSH
      - S3VpcEndpoint
      - VpcEndpointIgressBastionHTTPS
    Type: AWS::AutoScaling::AutoScalingGroup
    CreationPolicy:
      ResourceSignal:
        Count: 1
        Timeout: PT10M
    Properties:
      MinSize: "1"
      DesiredCapacity: "1"
      MaxSize: "1"
      HealthCheckGracePeriod: 300
      HealthCheckType: ELB
      LaunchTemplate:
          LaunchTemplateId: !Ref BastionLaunchTemplate
          Version: !GetAtt BastionLaunchTemplate.LatestVersionNumber
      MaxInstanceLifetime: 604800
      VPCZoneIdentifier: 
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
        # Can't launch in 3 because don't have a listener in this AZ.
        #- !Ref PrivateSubnet3
      Tags:
        - Key: Name
          Value: !Sub "${ClusterId}-Bastion"
          PropagateAtLaunch: true
        - Key: soca:ClusterId
          Value: !Sub ${ClusterId}
          PropagateAtLaunch: true
      TargetGroupARNs: 
        - !Ref BastionNLBTargetGroup

  #============================================================================
  # ImageBuilder Security Group
  #============================================================================

  ImageBuilderSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: SG for AMI creation
      Tags:
        - Key: Name
          Value: !Sub ${ClusterId}-CreateAMI
        - Key: soca:ClusterId
          Value: !Ref ClusterId

  ImageBuilderIngressClientIpSSH:
    Condition: HasClientIp
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      CidrIp: !Ref ClientIp
      GroupId: !GetAtt ImageBuilderSecurityGroup.GroupId
      Description: "Allow SSH traffic from client IP to master host"

  ImageBuilderIngressPrefixListSSH:
    Condition: HasPrefixListId
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      SourcePrefixListId: !Ref PrefixListId
      GroupId: !GetAtt ImageBuilderSecurityGroup.GroupId
      Description: "Allow SSH traffic from client IP to master host"

  ImageBuilderIngressBastionSSH:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      SourceSecurityGroupId: !Ref BastionSecurityGroup
      GroupId: !GetAtt ImageBuilderSecurityGroup.GroupId
      Description: "Allow SSH traffic from client IP to master host"

  #============================================================================
  # Proxy server
  #============================================================================

  ProxyEC2Instance:
    DependsOn:
      - EC2VpcEndpoint
      - ProxyEgressInternetHTTP
      - ProxyEgressInternetHTTPS
      - ProxyEgressS3Http
      - ProxyEgressS3Https
      - ProxyEgressVpcEndpointHTTP
      - ProxyEgressVpcEndpointHTTPS
      - S3VpcEndpoint
      - VpcEndpointIngressProxyHTTPS
    Type: AWS::EC2::Instance
    CreationPolicy:
      ResourceSignal:
        Count: '1'
        Timeout: PT10M
    Properties:
      ImageId: !Ref AL2ImageId
      DisableApiTermination: false
      InstanceType: !Ref ProxyInstanceType
      IamInstanceProfile:
        Ref: ProxyIAMInstanceProfile
      BlockDeviceMappings:
        - DeviceName: "/dev/xvda"
          Ebs:
            VolumeSize: 150
            VolumeType: gp2
            Encrypted: true

      KeyName: !Ref SSHKeyPair

      NetworkInterfaces:
        - AssociatePublicIpAddress: "true"
          DeviceIndex: "0"
          GroupSet: 
            - !Ref ProxySecurityGroup
          SubnetId: !Ref ProxySubnetId

      Tags:
        - Key: Name
          Value: !Sub ${ClusterId}-Proxy
        - Key: soca:KeepForever
          Value: true
        - Key: soca:ClusterId
          Value: !Sub ${ClusterId}
        - Key: soca:NodeType
          Value: proxy
        - Key: soca:BackupPlan
          Value: !Sub ${ClusterId}

      UserData:
          "Fn::Base64": !Sub |
            #!/bin/bash -xe

            # Signal Cloudformation if the instance creates successfully or not
            yum -y install -y aws-cfn-bootstrap
            function on_exit {
                /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource ProxyEC2Instance --region ${AWS::Region} || true
            }
            trap on_exit EXIT

            yum -y update --security

            # Disable automatic motd update
            /usr/sbin/update-motd --disable
            rm -f /etc/cron.d/update-motd
            rm -f /etc/update-motd.d/*

            # Set up motd
            amazon-linux-extras install -y epel
            yum -y install figlet
            figlet -f slant "SOCA Proxy" > /etc/motd
            echo -e "Cluster: ${ClusterId}
            Configuration: /etc/squid/squid.conf
                           /etc/squid/soca.conf
            Logs: /var/log/squid/access.log
            " >> /etc/motd

            echo export "SOCA_CONFIGURATION=${ClusterId}" >> /etc/environment
            echo export "AWS_DEFAULT_REGION=${AWS::Region}" >> /etc/environment
            echo export "SOCA_INSTALL_BUCKET=${S3InstallBucket}" >> /etc/environment
            echo export "SOCA_INSTALL_BUCKET_FOLDER=${S3InstallFolder}" >> /etc/environmentenvironment
            echo export "SOCA_DOMAIN=${SocaDomain}" >> /etc/environment
            echo export "SOCA_HOSTED_ZONE_ID=${HostedZoneId}" >> /etc/environment
            source /etc/environment

            AWS=$(which aws)
            
            # Tag EBS disks manually as CFN ASG does not support it
            AWS_AVAIL_ZONE=$(curl http://169.254.169.254/latest/meta-data/placement/availability-zone)
            AWS_REGION="`echo \"$AWS_AVAIL_ZONE\" | sed "s/[a-z]$//"`"
            AWS_INSTANCE_ID=$(curl http://169.254.169.254/latest/meta-data/instance-id)
            EBS_IDS=$(aws ec2 describe-volumes --filters Name=attachment.instance-id,Values="$AWS_INSTANCE_ID" --region $AWS_REGION --query "Volumes[*].[VolumeId]" --out text | tr "\n" " ")
            aws ec2 create-tags --resources $EBS_IDS --region $AWS_REGION --tags Key=Name,Value="${ClusterId} Root Disk" "Key=soca:ClusterId,Value=${ClusterId}"

            # Tag Network Adapter for the Proxy
            ENI_IDS=$(aws ec2 describe-network-interfaces --filters Name=attachment.instance-id,Values="$AWS_INSTANCE_ID" --region $AWS_REGION --query "NetworkInterfaces[*].[NetworkInterfaceId]" --out text | tr "\n" " ")
            aws ec2 create-tags --resources $ENI_IDS --region $AWS_REGION --tags Key=Name,Value="${ClusterId} Proxy Network Adapter" "Key=soca:ClusterId,Value=${ClusterId}"

            # Configure using ansible
            amazon-linux-extras install -y ansible2
            aws s3 cp --recursive s3://${S3InstallBucket}/${S3InstallFolder}/playbooks/ /root/playbooks/
            cd /root/playbooks
            ansible-playbook proxy.yml -e Region=${AWS::Region} -e Domain=${SocaDomain} -e S3InstallBucket=${S3InstallBucket} -e S3InstallFolder=${S3InstallFolder} -e ClusterId=${ClusterId} -e NodeType=proxy >> /root/ansible.log 2>&1

            /opt/aws/bin/cfn-signal -e 0 --stack ${AWS::StackName} --resource ProxyEC2Instance --region ${AWS::Region} || true

            if ! needs-restarting -r; then
              reboot
            fi

  ProxyDnsRecord:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !Ref UpdateDnsLambdaArn
      Hostname: "proxy"
      Domain: !Ref SocaDomain
      HostedZoneId: !Ref HostedZoneId
      Type: 'A'
      PrivateIP: !GetAtt ProxyEC2Instance.PrivateIp

  #============================================================================
  # Custom resource to get proxy CA certificate generated by proxy server
  # This is used by the bastion and all other proxied instances so they can
  # use the proxy.
  #============================================================================

  GetProxyCACertLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: GetProxyCACert
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:DeleteLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":logs:", !Ref "AWS::Region", ":", !Ref  "AWS::AccountId", ":log-group:/aws/lambda/", !Ref ClusterId, "*"] ]

              - Effect: Allow
                Action:
                  - ssm:DeleteParameter
                  - ssm:GetParameter
                Resource:
                  - !Sub 'arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${ClusterId}/proxy/cacert'

  GetProxyCACertLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Get proxy CA certificate
      FunctionName: !Sub "${ClusterId}-GetProxyCACert"
      Handler: index.lambda_handler
      MemorySize: 128
      Role: !GetAtt GetProxyCACertLambdaRole.Arn
      Runtime: python3.7
      Timeout: 180
      Tags:
        - Key: soca:ClusterId
          Value: !Ref ClusterId
      Code:
        ZipFile: !Sub |
          import cfnresponse
          import boto3
          import logging
          '''
          Get prefix list id
          '''
          logging.getLogger().setLevel(logging.INFO)
          def lambda_handler(event, context):
            try:
              logging.info("event: {}".format(event))
              ssm_client = boto3.client('ssm')
              parameterName = '/${ClusterId}/proxy/cacert'
              requestType = event['RequestType']
              if requestType in ['Create', 'Update']:
                proxyCACert = ssm_client.get_parameter(Name=parameterName)['Parameter']['Value']
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {'cacert': proxyCACert}, parameterName)
              elif requestType == 'Delete':
                ssm_client.delete_parameter(Name=parameterName)
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {'cacert': ''}, parameterName)
              else:
                raise ValueError('Invalid RequestType: {}'.format(event['RequestType']))
            except:
              logging.exception("Unhandled exception")
              error_message = 'Exception getting /${ClusterId}/proxy/cacert'
              cfnresponse.send(event, context, cfnresponse.FAILED, {'error': error_message}, error_message)

  ProxyCACert:
    DependsOn: ProxyEC2Instance
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt GetProxyCACertLambda.Arn

  #============================================================================
  # Proxy Security Group
  #============================================================================

  ProxySecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: SG For Proxy Host
      Tags:
        - Key: Name
          Value: !Sub ${ClusterId}-ProxySG
        - Key: soca:ClusterId
          Value: !Ref ClusterId

  ProxyIngressBastionSquid:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 3128
      ToPort: 3128
      SourceSecurityGroupId: !GetAtt BastionSecurityGroup.GroupId
      GroupId: !GetAtt ProxySecurityGroup.GroupId
      Description: "Bastion"

  ProxyInboundRuleComputeNode:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 3128
      ToPort: 3128
      SourceSecurityGroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      GroupId: !GetAtt ProxySecurityGroup.GroupId
      Description: "ComputeNode"

  ProxyInboundRuleScheduler:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 3128
      ToPort: 3128
      SourceSecurityGroupId: !GetAtt SchedulerSecurityGroup.GroupId
      GroupId: !GetAtt ProxySecurityGroup.GroupId
      Description: "Scheduler"

  ProxyIgressBastionSSH:
    Condition: HasClientIp
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      SourceSecurityGroupId: !GetAtt BastionSecurityGroup.GroupId
      GroupId: !GetAtt ProxySecurityGroup.GroupId
      Description: "Bastion"

  ProxyEgressInternetHTTP:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80
      CidrIp: 0.0.0.0/0
      GroupId: !GetAtt ProxySecurityGroup.GroupId
      Description: Internet

  ProxyEgressInternetHTTPS:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      CidrIp: 0.0.0.0/0
      GroupId: !GetAtt ProxySecurityGroup.GroupId
      Description: Internet

  ProxyEgressS3Http:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80
      DestinationPrefixListId: !GetAtt S3PrefixList.Id
      GroupId: !GetAtt ProxySecurityGroup.GroupId
      Description: "S3 Endpoints"

  ProxyEgressS3Https:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      DestinationPrefixListId: !GetAtt S3PrefixList.Id
      GroupId: !GetAtt ProxySecurityGroup.GroupId
      Description: "S3 Endpoints"

  ProxyEgressVpcEndpointHTTP:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80
      DestinationSecurityGroupId: !GetAtt VpcEndpointSecurityGroup.GroupId
      GroupId: !GetAtt ProxySecurityGroup.GroupId
      Description: VpcEndpoint

  ProxyEgressVpcEndpointHTTPS:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      DestinationSecurityGroupId: !GetAtt VpcEndpointSecurityGroup.GroupId
      GroupId: !GetAtt ProxySecurityGroup.GroupId
      Description: VpcEndpoint

  #============================================================================
  # Scheduler Security Group
  #============================================================================

  SchedulerSecurityGroup:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W5
            reason: "All access for Egress traffic"
          - id: W27
            reason: "All traffic permitted between Scheduler and Compute Nodes"
          - id: W29
            reason: "All ports open for Egress traffic - esp required in case of FlexLM licensing"
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: SG For Scheduler Host
      Tags:
        - Key: Name
          Value: !Sub ${ClusterId}-SchedulerSG
        - Key: soca:ClusterId
          Value: !Ref ClusterId

  SchedulerInboundRuleLoadBalancer:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 8443
      ToPort: 8443
      SourceSecurityGroupId: !GetAtt LoadBalancerSecurityGroup.GroupId
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: "LoadBalancer - Allow ELB healtcheck to communicate with web ui on master host"

  SchedulerInboundRuleComputeNodeLDAP:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 389
      ToPort: 389
      SourceSecurityGroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: "ComputeNode - LDAP"

  SchedulerInboundRuleComputeNodeEphemeral:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 1024
      ToPort: 65535
      SourceSecurityGroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: "ComputeNode"

  SchedulerInboundRuleAllowBastionSSH:
    Condition: HasClientIp
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      SourceSecurityGroupId: !GetAtt BastionSecurityGroup.GroupId
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: "Bastion"

  SchedulerInboundRuleAllowClientIPSSH:
    Condition: HasClientIp
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      CidrIp: !Ref ClientIp
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: "ClientIp"

  SchedulerInboundRuleAllowPrefixListSSH:
    Condition: HasPrefixListId
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      SourcePrefixListId: !Ref PrefixListId
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: "ClientPrefixList"

  SchedulerInboundRuleAllowClientIPHTTPS:
    Condition: HasClientIp
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      CidrIp: !Ref ClientIp
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: "ClientIP"

  SchedulerInboundRuleAllowPrefixListHTTP:
    Condition: HasPrefixListId
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80
      SourcePrefixListId: !Ref PrefixListId
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: "ClientPrefixList"

  SchedulerInboundRuleAllowPrefixListHTTPS:
    Condition: HasPrefixListId
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourcePrefixListId: !Ref PrefixListId
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: "ClientPrefixList"

  SchedulerOutboundComputeNodePrivileged:
    # I don't know why this is required, but Scheduler is using privileged ports
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 0
      ToPort: 1024
      DestinationSecurityGroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: ComputeNode

  SchedulerOutboundComputeNodeEphemeral:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 1024
      ToPort: 65535
      DestinationSecurityGroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: ComputeNode

  SchedulerOutboundProxy:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 3128
      ToPort: 3128
      DestinationSecurityGroupId: !GetAtt ProxySecurityGroup.GroupId
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: Proxy

  SchedulerOutboundVpcEndpointHttp:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80
      DestinationSecurityGroupId: !GetAtt VpcEndpointSecurityGroup.GroupId
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: VpcEndpoint

  SchedulerOutboundVpcEndpointHttps:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      DestinationSecurityGroupId: !GetAtt VpcEndpointSecurityGroup.GroupId
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: VpcEndpoint

  SchedulerOutboundS3Http:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80
      DestinationPrefixListId: !GetAtt S3PrefixList.Id
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: "S3 Endpoints"

  SchedulerOutboundS3Https:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      DestinationPrefixListId: !GetAtt S3PrefixList.Id
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: "S3 Endpoints"

  SchedulerOutboundInternetHttps:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      CidrIp: '0.0.0.0/0'
      GroupId: !GetAtt SchedulerSecurityGroup.GroupId
      Description: "S3 Endpoints"

  #============================================================================
  # ComputeNode Security Group
  #============================================================================

  ComputeNodeSecurityGroup:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W5
            reason: "All CIDR access for Egress traffic"
          - id: W27
            reason: "All traffic permitted between Scheduler and Compute Nodes"
          - id: W29
            reason: "All ports open for Egress traffic - esp required in case of FlexLM licensing"
          - id: W40
            reason: "All traffic egress traffic required for EFA"
          - id: W42
            reason: "All traffic ingress traffic required for EFA"

    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: SG For all Compute Nodes
      Tags:
        - Key: Name
          Value: !Sub ${ClusterId}-ComputeNodeSG
        - Key: soca:ClusterId
          Value: !Ref ClusterId

  ComputeNodeInboundRuleLoadBalancer:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 8443
      ToPort: 8443
      SourceSecurityGroupId: !GetAtt LoadBalancerSecurityGroup.GroupId
      GroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      Description: "LoadBalancer - Allow ELB healtcheck"

  ComputeNodeInboundRuleSchedulerPrivileged:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 0
      ToPort: 1024
      SourceSecurityGroupId: !GetAtt SchedulerSecurityGroup.GroupId
      GroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      Description: "Scheduler"

  ComputeNodeInboundRuleSchedulerEphemeral:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 1024
      ToPort: 65535
      SourceSecurityGroupId: !GetAtt SchedulerSecurityGroup.GroupId
      GroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      Description: "Scheduler"

  ComputeNodeInboundRuleBastionSSH:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      SourceSecurityGroupId: !GetAtt BastionSecurityGroup.GroupId
      GroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      Description: "Bastion"

  ComputeNodeInboundRuleComputeNodeSSH:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      SourceSecurityGroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      GroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      Description: "ComputeNode"

  ComputeNodeInboundRuleItSelf:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 1024
      ToPort: 65535
      SourceSecurityGroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      GroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      Description: "ComputeNode"

  ComputeNodeOutboundItself:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 1024
      ToPort: 65535
      DestinationSecurityGroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      GroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      Description: "ComputeNode"

  ComputeNodeOutboundSchedulerLDAP:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 389
      ToPort: 389
      DestinationSecurityGroupId: !GetAtt SchedulerSecurityGroup.GroupId
      GroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      Description: "Scheduler LDAP"

  ComputeNodeOutboundSchedulerEphemeral:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 1024
      ToPort: 65535
      DestinationSecurityGroupId: !GetAtt SchedulerSecurityGroup.GroupId
      GroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      Description: "Scheduler Ephemeral"

  ComputeNodeOutboundProxy:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 3128
      ToPort: 3128
      DestinationSecurityGroupId: !GetAtt ProxySecurityGroup.GroupId
      GroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      Description: "Proxy"

  ComputeNodeOOutboundS3Http:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80
      DestinationPrefixListId: !GetAtt S3PrefixList.Id
      GroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      Description: "S3 Endpoints"

  ComputeNodeOOutboundS3Https:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      DestinationPrefixListId: !GetAtt S3PrefixList.Id
      GroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      Description: "S3 Endpoints"

  ComputeNoteOutboundVpcEndpointHttp:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80
      DestinationSecurityGroupId: !GetAtt VpcEndpointSecurityGroup.GroupId
      GroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      Description: VpcEndpoint

  ComputeNoteOutboundVpcEndpointHttps:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      DestinationSecurityGroupId: !GetAtt VpcEndpointSecurityGroup.GroupId
      GroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      Description: VpcEndpoint

  #============================================================================
  # LoadBalancer Security Group
  #============================================================================

  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: SG For LoadBalancer
      Tags:
        - Key: Name
          Value: !Sub ${ClusterId}-LoadBalancerSG
        - Key: soca:ClusterId
          Value: !Ref ClusterId

  LoadBalancerInboundRuleAllowClientIPHTTP:
    Condition: HasClientIp
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80
      CidrIp: !Ref ClientIp
      GroupId: !GetAtt LoadBalancerSecurityGroup.GroupId
      Description: "ClientIP"

  LoadBalancerInboundRuleClientIPHttps:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      CidrIp: !Ref ClientIp
      GroupId: !GetAtt LoadBalancerSecurityGroup.GroupId
      Description: "ClientIP"

  LoadBalancerInboundRuleAllowPrefixListHTTP:
    Condition: HasPrefixListId
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80
      SourcePrefixListId: !Ref PrefixListId
      GroupId: !GetAtt LoadBalancerSecurityGroup.GroupId
      Description: "Client PrefixList"

  LoadBalancerInboundRulePrefixListHttps:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourcePrefixListId: !Ref PrefixListId
      GroupId: !GetAtt LoadBalancerSecurityGroup.GroupId
      Description: "Client PrefixList"

  LoadBalancerInboundRuleAllowSchedulerIPHTTPS:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      CidrIp: !Join [ "", [ !Ref SchedulerPublicIP, "/32" ] ]
      GroupId: !GetAtt LoadBalancerSecurityGroup.GroupId
      Description: "Scheduler Public IP - Allow HTTPS traffic to validate DCV sessions"

  LoadBalancerInboundRuleAllowNATIPHTTPS:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      CidrIp: !Join [ "", [ !Ref EIPNat, "/32" ] ]
      GroupId: !GetAtt LoadBalancerSecurityGroup.GroupId
      Description: "NAT IP - Allow HTTPS traffic from Compute Nodes to ELB"

  LoadBalancerInboundRuleAllowProxyHTTPS:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      CidrIp: !Join [ "", [ !GetAtt ProxyEC2Instance.PublicIp, "/32" ] ]
      GroupId: !GetAtt LoadBalancerSecurityGroup.GroupId
      Description: "Proxy - Allow HTTPS traffic from Compute Nodes to ELB"

  LoadBalancerOutboundRuleAllowScheduler8443:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 8443
      ToPort: 8443
      DestinationSecurityGroupId: !GetAtt SchedulerSecurityGroup.GroupId
      GroupId: !GetAtt LoadBalancerSecurityGroup.GroupId
      Description: Scheduler - ELB Health checks

  LoadBalancerOutboundRuleAllowComputeNode8443:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      IpProtocol: tcp
      FromPort: 8443
      ToPort: 8443
      DestinationSecurityGroupId: !GetAtt ComputeNodeSecurityGroup.GroupId
      GroupId: !GetAtt LoadBalancerSecurityGroup.GroupId
      Description: ComputeNode - ELB Health checks

  #============================================================================
  # Begin IAM
  #============================================================================

  ComputeNodeIAMRole:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: "* is reduced to minimal pattern"


    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - !Sub "ec2.${AWS::URLSuffix}"
                - !Sub "ssm.${AWS::URLSuffix}"
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore # Support for SSM
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy  # Support for CloudwatchAgent
      Policies:
        - PolicyName: ComputeNodePermissions
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                  - s3:PutObject
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":s3:::", !Ref S3InstallBucket , "/*" ] ]
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":s3:::", !Ref S3InstallBucket] ]
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":s3:::dcv-license.", !Ref "AWS::Region", "/*"] ]
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":s3:::ec2-linux-nvidia-drivers", "/*"] ]
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":s3:::ec2-linux-nvidia-drivers"] ]
                  - !Sub "arn:${AWS::Partition}:s3:::amazoncloudwatch-agent-${AWS::Region}"
                  - !Sub "arn:${AWS::Partition}:s3:::amazoncloudwatch-agent-${AWS::Region}/*"
                  - !If [ HasRepository, !Sub "arn:${AWS::Partition}:s3:::${RepositoryBucket}/${RepositoryFolder}/*", !Ref 'AWS::NoValue' ]

              - Effect: Allow
                Action:
                  -  ses:SendEmail
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":ses:*:", !Ref  "AWS::AccountId", ":identity*"] ]

              - Effect: Allow
                Action:
                  - ec2:CreateTags
                Resource:
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:volume/*"
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:network-interface/*"

              - Effect: Allow
                Action:
                  - ec2:DescribeVolumes
                  - ec2:DescribeNetworkInterfaces
                  - fsx:CreateDataRepositoryTask
                  - fsx:DescribeFileSystems # For FSX
                  - tag:GetResources # For FSX detection
                  - tag:GetTagValues # For FSX detection
                  - tag:GetTagKeys # For FSX detection
                Resource: "*"

  ComputeNodeInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref ComputeNodeIAMRole
      #InstanceProfileName: !Sub ${ClusterId}-ComputeNodeInstanceProfile

  SpotFleetIAMRole:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: "* is reduced to minimal pattern"
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - !Sub "spotfleet.${AWS::URLSuffix}"
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: SpotFleetPermissions
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeImages
                  - ec2:DescribeSubnets
                  - ec2:DescribeInstanceStatus
                Resource: "*"
              - Effect: Allow
                Action:
                  - ec2:RequestSpotInstances
                  - ec2:TerminateInstances
                  - ec2:CreateTags
                Resource:
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:instance/*"
                Condition:
                  "ForAllValues:ArnEqualsIfExists":
                      "ec2:Vpc": !Sub "arn:${AWS::Partition}:ec2:${AWS::Region}:*:vpc/${VpcId}"
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource:
                  - !GetAtt ComputeNodeIAMRole.Arn
                Condition:
                  "StringEquals":
                      "iam:PassedToService": ["ec2.amazonaws.com", "ec2.amazonaws.com.cn"]

  ProxyIAMRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - !Sub "ec2.${AWS::URLSuffix}"
                - !Sub "ssm.${AWS::URLSuffix}"
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore # Support for SSM
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy  # Support for CloudwatchAgent

      Policies:
        - PolicyName: ProxyPermissions
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":s3:::", !Ref S3InstallBucket , "/*" ] ]
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":s3:::", !Ref S3InstallBucket] ]
                  - !If [ HasRepository, !Sub "arn:${AWS::Partition}:s3:::${RepositoryBucket}/${RepositoryFolder}/*", !Ref 'AWS::NoValue' ]

              - Effect: Allow
                Action:
                  - ec2:CreateTags
                Resource:
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:volume/*"
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:network-interface/*"

              - Effect: Allow
                Action:
                  - ec2:DescribeVolumes
                  - ec2:DescribeNetworkInterfaces
                Resource: "*"

              - Effect: Allow
                Action:
                  - route53:ChangeResourceRecordSets
                Resource: "*"

              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:PutParameter
                Resource:
                  - !Sub "arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${ClusterId}/proxy/cacert"

  ProxyIAMInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref ProxyIAMRole

  SchedulerIAMRole:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: "API calls are read commands which have to be mapped to wildcard resources"
          - id: W76
            reason: "Stelligent Policy Complexity Metric (SPCM) already reduced to minimum"

    Type: AWS::IAM::Role
    DependsOn: ComputeNodeIAMRole
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - !Sub "ec2.${AWS::URLSuffix}"
                - !Sub "ssm.${AWS::URLSuffix}"
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore # Support for SSM
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy  # Support for CloudwatchAgent
      Policies:
        - PolicyName: SchedulerReadPermissions
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - pricing:GetProducts
                  - budgets:ViewBudget
                  - ec2:DescribeInstances
                  - ec2:DescribeSubnets
                  - ec2:DescribeSecurityGroups
                  - ec2:DescribeImages
                  - ec2:DescribeInstanceAttribute
                  - ec2:DescribeInstanceTypes
                  - ec2:DescribeInstanceStatus
                  - ec2:DescribeReservedInstances
                  - ec2:DescribeSpotInstanceRequests
                  - ec2:DescribeVpcClassicLink
                  - ec2:DescribeVolumes
                  - ec2:DescribePlacementGroups
                  - ec2:DescribeKeyPairs
                  - ec2:DescribeLaunchTemplates
                  - ec2:DescribeLaunchTemplateVersions
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DescribeSpotFleetRequests
                  - ec2:DescribeSpotFleetInstances
                  - fsx:DescribeFileSystems
                  - autoscaling:DescribeAutoScalingGroups
                  - autoscaling:DescribeScalingActivities
                  - autoscaling:DescribeLaunchConfigurations
                  - elasticloadbalancing:DescribeRules
                  - elasticloadbalancing:DescribeListeners
                  - elasticloadbalancing:DescribeTargetGroups
                  - savingsplans:DescribeSavingsPlans
                  - servicequotas:ListServiceQuotas
                  - ssm:ListDocuments
                  - ssm:ListDocumentVersions
                  - ssm:DescribeDocument
                  - ssm:GetDocument
                  - ssm:DescribeInstanceInformation
                  - ssm:DescribeDocumentParameters
                  - ssm:DescribeInstanceProperties
                  - ssm:ListCommands
                  - ssm:GetCommandInvocation
                  - ssm:DescribeAutomationExecutions
                Resource: "*"

        - PolicyName: SchedulerWritePermissions
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - autoscaling:UpdateAutoScalingGroup
                  - autoscaling:DeleteAutoScalingGroup
                  - autoscaling:CreateAutoScalingGroup
                  - autoscaling:DetachInstances
                  - ec2:DeleteLaunchTemplate
                  - ec2:CreateLaunchTemplate
                  - fsx:CreateDataRepositoryTask
                Resource: "*"
                Condition:
                  StringLikeIfExists:
                    "autoscaling:LaunchConfigurationName": !Sub "${ClusterId}*"

              - Effect: Allow
                Action:
                  - ec2:CreateTags
                Resource:
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:volume/*"
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:network-interface/*"
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:instance/*"

              - Effect: Allow
                Action:
                  - cloudformation:CreateStack
                  - cloudformation:DeleteStack
                  - cloudformation:DescribeStacks
                Resource: "*"
                Condition:
                  "ForAllValues:StringEquals":
                    "cloudformation:TemplateURL": !Sub "https://s3.{AWS::URLSuffix}/${S3InstallBucket}/${S3InstallFolder}/templates/ComputeNode.template"

              - Effect: Allow
                Action:
                  - ec2:RunInstances
                  - ec2:StopInstances
                  - ec2:StartInstances
                  - ec2:TerminateInstances
                  - ec2:CreatePlacementGroup
                  - ec2:DeletePlacementGroup
                  - ec2:ModifyInstanceAttribute
                Resource:
                  - !Sub "arn:${AWS::Partition}:ec2:*:*:subnet/*"
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:key-pair/*"
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:instance/*"
                  - !Sub "arn:${AWS::Partition}:ec2:*::snapshot/*"
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:launch-template/*"
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:volume/*"
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:security-group/*"
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:placement-group/*"
                  - !Sub "arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:network-interface/*"
                  - !Sub "arn:${AWS::Partition}:ec2:*::image/*"
                Condition:
                  "ForAllValues:ArnEqualsIfExists":
                      "ec2:Vpc": !Sub "arn:${AWS::Partition}:ec2:${AWS::Region}:*:vpc/${VpcId}"

              - Effect: Allow
                Action:
                  - ssm:SendCommand
                Resource:
                  - !Sub "arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:instance/*"
                  - !Sub "arn:${AWS::Partition}:ssm:${AWS::Region}::document/AWS-RunPowerShellScript"
                  - !Sub "arn:${AWS::Partition}:ssm:${AWS::Region}::document/AWS-RunShellScript"

              - Effect: Allow
                Action:
                  - ssm:StartAutomationExecution
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":ssm:", ":::automation-definition/"] ]

              - Effect: Allow
                Action:
                  - ssm:StopAutomationExecution
                  - ssm:GetAutomationExecution
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":ssm:", ":::automation-execution/"] ]

              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":lambda:", !Ref "AWS::Region", ":", !Ref  "AWS::AccountId", ":function:", !Ref ClusterId, "-Metrics"] ]

              - Effect: Allow
                Action:
                  - fsx:CreateFileSystem
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":fsx:", !Ref "AWS::Region", ":", !Ref  "AWS::AccountId", ":file-system/*"] ]

              - Effect: Allow
                Action:
                  - fsx:DeleteFileSystem
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":fsx:", !Ref "AWS::Region", ":", !Ref  "AWS::AccountId", ":file-system/*"] ]
                Condition:
                  "StringLike":
                    "aws:ResourceTag/soca:ClusterId": !Sub "${ClusterId}*"

              - Effect: Allow
                Action:
                  - iam:CreateServiceLinkedRole
                  - iam:AttachRolePolicy
                  - iam:PutRolePolicy
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":iam::", !Ref "AWS::AccountId", ":", "role/aws-service-role/s3.data-source.lustre.fsx.amazonaws.com/*"] ]
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":iam::", !Ref "AWS::AccountId", ":", "role/aws-service-role/autoscaling.amazonaws.com/*"] ]
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":iam::", !Ref "AWS::AccountId", ":", "role/aws-service-role/spotfleet.amazonaws.com/*"] ]
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":iam::", !Ref "AWS::AccountId", ":", "role/aws-service-role/fsx.amazonaws.com/*"] ]

              - Effect: Allow
                Action:
                  -  ses:SendEmail
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":ses:", !Ref "AWS::Region", ":", !Ref  "AWS::AccountId", ":identity*"] ]

              - Effect: Allow
                Action:
                  - ec2:CreatePlacementGroup
                  - ec2:DeletePlacementGroup
                  - ec2:RequestSpotFleet
                  - ec2:ModifySpotFleetRequest
                  - ec2:CancelSpotFleetRequests
                Resource: "*"
                Condition:
                  "ForAllValues:ArnEqualsIfExists":
                      "ec2:Vpc": !Sub "arn:${AWS::Partition}:ec2:${AWS::Region}:*:vpc/${VpcId}"

              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                  - s3:PutObject
                Resource:
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":s3:::", !Ref S3InstallBucket , "/*" ] ]
                  - !Join [ "", [ "arn:", !Ref "AWS::Partition", ":s3:::", !Ref S3InstallBucket] ]

              - Effect: Allow
                Action:
                  - iam:PassRole
                  - iam:CreateServiceLinkedRole
                Resource:
                  - !GetAtt ComputeNodeIAMRole.Arn
                  - !GetAtt SpotFleetIAMRole.Arn
                Condition:
                  "ForAllValues:ArnEqualsIfExists":
                      "ec2:Vpc": !Sub "arn:${AWS::Partition}:ec2:${AWS::Region}:*:vpc/${VpcId}"

  SchedulerIAMInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref SchedulerIAMRole

  LambdaSolutionMetricRole:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: "* is reduced to minimal pattern"

    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: SolutionMetric
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                Resource: !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${ClusterId}*"

              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:DeleteLogStream
                Resource: !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${ClusterId}*:log-stream:*"

  LambdaACMIAMRole:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: "* is reduced to minimal pattern"
          - id: W28
            reason: "Name is required to easily identify resource deployed by SOCA"

    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - !Sub lambda.${AWS::URLSuffix}
            Action:
              - sts:AssumeRole

      Policies:
        - PolicyName: !Sub ${ClusterId}-LambdaACMIamRole-Policy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                Resource: !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${ClusterId}*"

              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${ClusterId}*:log-stream:*"

              - Effect: Allow
                Action:
                  - acm:ImportCertificate
                  - acm:ListCertificates
                  - acm:AddTagsToCertificate
                Resource: "*"

  #============================================================================
  # GuardDuty
  #============================================================================

  # This can only be set up once per account so can't create new one if alreasdy configured.
  # Replace this with a lambda that checks for Detector and creates one if it doesn't already exist.
  # Create a custom resource that returns the id of the existing or new Detector.
  # GuardDuty:
  #   Type: AWS::GuardDuty::Detector
  #   Properties:
  #     DataSources:
  #       S3Logs:
  #         Enable: true
  #     Enable: True
  #     # Allowed values: FIFTEEN_MINUTES | ONE_HOUR | SIX_HOURS
  #     FindingPublishingFrequency: FIFTEEN_MINUTES

Outputs:
  SchedulerIAMRole:
    Value: !Ref SchedulerIAMRole
  SchedulerIAMRoleArn:
    Value: !GetAtt SchedulerIAMRole.Arn
  SpotFleetIAMRoleArn:
    Value: !GetAtt SpotFleetIAMRole.Arn
  SolutionMetricsRole:
    Value: !Ref LambdaSolutionMetricRole
  SolutionMetricsRoleArn:
    Value: !GetAtt LambdaSolutionMetricRole.Arn
  SchedulerIAMInstanceProfile:
    Value: !Ref SchedulerIAMInstanceProfile
  SchedulerIAMInstanceProfileArn:
    Value: !GetAtt SchedulerIAMInstanceProfile.Arn
  ComputeNodeIAMRole:
    Value: !Ref ComputeNodeIAMRole
  ComputeNodeIAMRoleArn:
    Value: !GetAtt ComputeNodeIAMRole.Arn
  ComputeNodeInstanceProfile:
    Value: !Ref ComputeNodeInstanceProfile
  ComputeNodeInstanceProfileArn:
    Value: !GetAtt ComputeNodeInstanceProfile.Arn
  ImageBuilderSecurityGroup:
    Value: !GetAtt ImageBuilderSecurityGroup.GroupId
  LoadBalancerSecurityGroup:
    Value: !GetAtt LoadBalancerSecurityGroup.GroupId
  SchedulerSecurityGroup:
    Value: !GetAtt SchedulerSecurityGroup.GroupId
  ComputeNodeSecurityGroup:
    Value: !GetAtt ComputeNodeSecurityGroup.GroupId
  LambdaACMIAMRoleArn:
    Value: !GetAtt LambdaACMIAMRole.Arn
  BastionDnsName:
    Value: !GetAtt BastionNLB.DNSName
  ProxyPrivateDnsName:
    Value: !Sub "proxy.${SocaDomain}"
  NoProxy:
    Value: !Ref NoProxy
  ProxyCACertParameter:
    Value: !Sub "/${ClusterId}/proxy/cacert"
